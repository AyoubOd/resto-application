import Formatter from './formatter';
import { RuntimeConfig, WrapAttributes } from './runtimeConfig';
export interface CLIOption {
    write?: boolean;
    diff?: boolean;
    checkFormatted?: boolean;
    progress?: boolean;
    ignoreFilePath?: string;
    runtimeConfigPath?: string;
}
export interface FormatterOption {
    indentSize?: number;
    wrapLineLength?: number;
    wrapAttributes?: WrapAttributes;
    endWithNewline?: boolean;
    useTabs?: boolean;
    sortTailwindcssClasses?: true;
}
declare class BladeFormatter {
    diffs: any;
    errors: any;
    formattedFiles: any;
    ignoreFile: any;
    options: FormatterOption & CLIOption;
    outputs: any;
    currentTargetPath: string;
    paths: any;
    targetFiles: any;
    fulFillFiles: any;
    static targetFiles: any;
    runtimeConfigCache: RuntimeConfig;
    constructor(options?: FormatterOption & CLIOption, paths?: any);
    format(content: any, opts?: {}): Promise<any>;
    formatFromCLI(): Promise<void>;
    fileExists(filepath: string): any;
    readIgnoreFile(filePath: string): Promise<void>;
    readRuntimeConfig(filePath: string): Promise<RuntimeConfig | undefined>;
    processPaths(): Promise<void>;
    processPath(path: any): Promise<void>;
    static globFiles(path: any): Promise<unknown>;
    filterFiles(paths: any): Promise<any>;
    static fulFillFiles(paths: any): Promise<any>;
    formatFiles(paths: any): Promise<void>;
    formatFile(path: any): Promise<void>;
    checkFormatted(path: any, formatted: any): Promise<any>;
    printFormattedOutput(path: any, formatted: any): void;
    writeToFile(path: any, content: any): void;
    handleError(path: any, error: any): void;
    printPreamble(): void;
    printResults(): Promise<void>;
    printDescription(): void;
    printFormattedFiles(): void;
    printDifferences(): void;
    printErrors(): void;
}
export { BladeFormatter, Formatter };
